# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, MLX Contributors
# This file is distributed under the same license as the MLX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MLX 0.24\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-08 12:20+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../src/usage/compile.rst:4
msgid "Compilation"
msgstr "編譯"

#: ../../../src/usage/compile.rst:8
msgid ""
"MLX has a :func:`compile` function transformation which compiles computation "
"graphs. Function compilation results in smaller graphs by merging common "
"work and fusing certain operations. In many cases this can lead to big "
"improvements in run-time and memory use."
msgstr ""
"MLX 提供 :func:`compile` 函式變換，用於編譯計算圖。函式編譯會透過合併共用工作"
"與融合某些運算來得到更小的圖。在許多情況下，這能大幅改善執行時間與記憶體使用"
"量。"

#: ../../../src/usage/compile.rst:13
msgid ""
"Getting started with :func:`compile` is simple, but there are some edge "
"cases that are good to be aware of for more complex graphs and advanced "
"usage."
msgstr ""
"開始使用 :func:`compile` 很簡單，但對於更複雜的圖與進階用法，有一些邊界情況值"
"得注意。"

#: ../../../src/usage/compile.rst:17
msgid "Basics of Compile"
msgstr "Compile 的基礎"

#: ../../../src/usage/compile.rst:19
msgid "Let's start with a simple example:"
msgstr "先從一個簡單範例開始："

#: ../../../src/usage/compile.rst:21
msgid ""
"def fun(x, y):\n"
"    return mx.exp(-x) + y\n"
"\n"
"x = mx.array(1.0)\n"
"y = mx.array(2.0)\n"
"\n"
"# Regular call, no compilation\n"
"# Prints: array(2.36788, dtype=float32)\n"
"print(fun(x, y))\n"
"\n"
"# Compile the function\n"
"compiled_fun = mx.compile(fun)\n"
"\n"
"# Prints: array(2.36788, dtype=float32)\n"
"print(compiled_fun(x, y))"
msgstr ""

#: ../../../src/usage/compile.rst:39
msgid ""
"The output of both the regular function and the compiled function is the "
"same up to numerical precision."
msgstr "一般函式與編譯後函式的輸出在數值精度上是一致的。"

#: ../../../src/usage/compile.rst:42
msgid ""
"The first time you call a compiled function, MLX will build the compute "
"graph, optimize it, and generate and compile code. This can be relatively "
"slow. However, MLX will cache compiled functions, so calling a compiled "
"function multiple times will not initiate a new compilation. This means you "
"should typically compile functions that you plan to use more than once."
msgstr ""
"第一次呼叫已編譯的函式時，MLX 會建構計算圖、最佳化，並產生與編譯程式碼。這可"
"能相對較慢。不過 MLX 會快取已編譯的函式，因此多次呼叫不會再次觸發編譯。這表示"
"你通常應該只編譯會重複使用的函式。"

#: ../../../src/usage/compile.rst:48
msgid ""
"def fun(x, y):\n"
"    return mx.exp(-x) + y\n"
"\n"
"x = mx.array(1.0)\n"
"y = mx.array(2.0)\n"
"\n"
"compiled_fun = mx.compile(fun)\n"
"\n"
"# Compiled here\n"
"compiled_fun(x, y)\n"
"\n"
"# Not compiled again\n"
"compiled_fun(x, y)\n"
"\n"
"# Not compiled again\n"
"mx.compile(fun)(x, y)"
msgstr ""

#: ../../../src/usage/compile.rst:67
msgid ""
"There are some important cases to be aware of that can cause a function to "
"be recompiled:"
msgstr "有幾個重要情況會導致函式被重新編譯："

#: ../../../src/usage/compile.rst:70
msgid "Changing the shape or number of dimensions"
msgstr "變更形狀或維度數量"

#: ../../../src/usage/compile.rst:71
msgid "Changing the type of any of the inputs"
msgstr "變更任何輸入的型別"

#: ../../../src/usage/compile.rst:72
msgid "Changing the number of inputs to the function"
msgstr "變更函式輸入的數量"

#: ../../../src/usage/compile.rst:74
msgid ""
"In certain cases only some of the compilation stack will be rerun (for "
"example when changing the shapes) and in other cases the full compilation "
"stack will be rerun (for example when changing the types). In general you "
"should avoid compiling functions too frequently."
msgstr ""
"在某些情況下只會重新執行部分編譯流程（例如變更形狀），而在其他情況下會重新執"
"行完整編譯流程（例如變更型別）。一般而言，應避免太頻繁地編譯函式。"

#: ../../../src/usage/compile.rst:79
msgid ""
"Another idiom to watch out for is compiling functions which get created and "
"destroyed frequently. This can happen, for example, when compiling an "
"anonymous function in a loop:"
msgstr ""
"另一種需要留意的寫法是編譯會頻繁建立與銷毀的函式。例如在迴圈中編譯匿名函式："

#: ../../../src/usage/compile.rst:83
msgid ""
"a = mx.array(1.0)\n"
"# Don't do this, compiles lambda at each iteration\n"
"for _ in range(5):\n"
"    mx.compile(lambda x: mx.exp(mx.abs(x)))(a)"
msgstr ""

#: ../../../src/usage/compile.rst:91
msgid "Example Speedup"
msgstr "加速示例"

#: ../../../src/usage/compile.rst:93
msgid ""
"The :func:`mlx.nn.gelu` is a nonlinear activation function commonly used "
"with Transformer-based models. The implementation involves several unary and "
"binary element-wise operations:"
msgstr ""
" :func:`mlx.nn.gelu` 是常用於 Transformer 模型的非線性激活函式。實作包含多個"
"一元與二元逐元素運算："

#: ../../../src/usage/compile.rst:97
msgid ""
"def gelu(x):\n"
"    return x * (1 + mx.erf(x / math.sqrt(2))) / 2"
msgstr ""

#: ../../../src/usage/compile.rst:102
msgid ""
"If you use this function with small arrays, it will be overhead bound. If "
"you use it with large arrays it will be memory bandwidth bound.  However, "
"all of the operations in the ``gelu`` are fusible into a single kernel with :"
"func:`compile`. This can speedup both cases considerably."
msgstr ""
"若使用小陣列，這個函式會受限於開銷；若使用大陣列，則會受限於記憶體頻寬。不過 "
"``gelu`` 中所有運算都可透過 :func:`compile` 融合為單一核心，能在兩種情況下都"
"大幅加速。"

#: ../../../src/usage/compile.rst:107
msgid ""
"Let's compare the runtime of the regular function versus the compiled "
"function. We'll use the following timing helper which does a warm up and "
"handles synchronization:"
msgstr ""
"讓我們比較一般函式與編譯後函式的執行時間。我們會使用以下計時輔助函式，包含暖"
"身並處理同步："

#: ../../../src/usage/compile.rst:111
msgid ""
"import time\n"
"\n"
"def timeit(fun, x):\n"
"    # warm up\n"
"    for _ in range(10):\n"
"        mx.eval(fun(x))\n"
"\n"
"    tic = time.perf_counter()\n"
"    for _ in range(100):\n"
"        mx.eval(fun(x))\n"
"    toc = time.perf_counter()\n"
"    tpi = 1e3 * (toc - tic) / 100\n"
"    print(f\"Time per iteration {tpi:.3f} (ms)\")"
msgstr ""

#: ../../../src/usage/compile.rst:128
msgid "Now make an array, and benchmark both functions:"
msgstr "現在建立一個陣列並對兩個函式進行基準測試："

#: ../../../src/usage/compile.rst:130
msgid ""
"x = mx.random.uniform(shape=(32, 1000, 4096))\n"
"timeit(nn.gelu, x)\n"
"timeit(mx.compile(nn.gelu), x)"
msgstr ""

#: ../../../src/usage/compile.rst:136
msgid ""
"On an M1 Max the times are 15.5 and 3.1 milliseconds. The compiled ``gelu`` "
"is five times faster."
msgstr ""
"在 M1 Max 上，時間分別為 15.5 與 3.1 毫秒，編譯後的 ``gelu`` 快了五倍。"

#: ../../../src/usage/compile.rst:140
msgid "Debugging"
msgstr "除錯"

#: ../../../src/usage/compile.rst:142
msgid ""
"When a compiled function is first called, it is traced with placeholder "
"inputs. This means you can't evaluate arrays (for example to print their "
"contents) inside compiled functions."
msgstr ""
"編譯函式第一次被呼叫時會以占位輸入進行追蹤。這表示你無法在編譯函式內評估陣列"
"（例如列印其內容）。"

#: ../../../src/usage/compile.rst:146
msgid ""
"@mx.compile\n"
"def fun(x):\n"
"    z = -x\n"
"    print(z)  # Crash\n"
"    return mx.exp(z)\n"
"\n"
"fun(mx.array(5.0))"
msgstr ""

#: ../../../src/usage/compile.rst:156
msgid ""
"For debugging, inspecting arrays can be helpful. One way to do that is to "
"globally disable compilation using the :func:`disable_compile` function or "
"``MLX_DISABLE_COMPILE`` flag. For example the following is okay even though "
"``fun`` is compiled:"
msgstr ""
"為了除錯，檢視陣列很有幫助。一種作法是用 :func:`disable_compile` 或 "
"``MLX_DISABLE_COMPILE`` 旗標全域停用編譯。例如以下即使 ``fun`` 已編譯也沒問"
"題："

#: ../../../src/usage/compile.rst:161
msgid ""
"@mx.compile\n"
"def fun(x):\n"
"    z = -x\n"
"    print(z) # Okay\n"
"    return mx.exp(z)\n"
"\n"
"mx.disable_compile()\n"
"fun(mx.array(5.0))"
msgstr ""

#: ../../../src/usage/compile.rst:174
msgid "Pure Functions"
msgstr "純函式"

#: ../../../src/usage/compile.rst:176
msgid ""
"Compiled functions are intended to be *pure*; that is they should not have "
"side effects. For example:"
msgstr "編譯函式預期是*純函式*，也就是不應有副作用。例如："

#: ../../../src/usage/compile.rst:179
msgid ""
"state = []\n"
"\n"
"@mx.compile\n"
"def fun(x, y):\n"
"    z = x + y\n"
"    state.append(z)\n"
"    return mx.exp(z)\n"
"\n"
"fun(mx.array(1.0), mx.array(2.0))\n"
"# Crash!\n"
"print(state)"
msgstr ""

#: ../../../src/usage/compile.rst:193
msgid ""
"After the first call of ``fun``, the ``state`` list will hold a placeholder "
"array. The placeholder does not have any data; it is only used to build the "
"computation graph. Printing such an array results in a crash."
msgstr ""
"在第一次呼叫 ``fun`` 之後，``state`` 清單會包含一個占位陣列。這個占位陣列沒有"
"任何資料，只用來建構計算圖。列印這種陣列會造成崩潰。"

#: ../../../src/usage/compile.rst:197
msgid ""
"You have two options to deal with this. The first option is to simply return "
"``state`` as an output:"
msgstr "你有兩個做法可處理此問題。第一個是直接把 ``state`` 當作輸出回傳："

#: ../../../src/usage/compile.rst:200
msgid ""
"state = []\n"
"\n"
"@mx.compile\n"
"def fun(x, y):\n"
"   z = x + y\n"
"   state.append(z)\n"
"   return mx.exp(z), state\n"
"\n"
" _, state = fun(mx.array(1.0), mx.array(2.0))\n"
" # Prints [array(3, dtype=float32)]\n"
" print(state)"
msgstr ""

#: ../../../src/usage/compile.rst:214
msgid ""
"In some cases returning updated state can be pretty inconvenient. Hence, :"
"func:`compile` has a parameter to capture implicit outputs:"
msgstr ""
"有時回傳更新後的狀態很不方便。因此 :func:`compile` 提供參數來捕捉隱式輸出："

#: ../../../src/usage/compile.rst:217
msgid ""
"from functools import partial\n"
"\n"
"state = []\n"
"\n"
"# Tell compile to capture state as an output\n"
"@partial(mx.compile, outputs=state)\n"
"def fun(x, y):\n"
"    z = x + y\n"
"    state.append(z)\n"
"    return mx.exp(z), state\n"
"\n"
"fun(mx.array(1.0), mx.array(2.0))\n"
"# Prints [array(3, dtype=float32)]\n"
"print(state)"
msgstr ""

#: ../../../src/usage/compile.rst:234
msgid ""
"This is particularly useful for compiling a function which includes an "
"update to a container of arrays, as is commonly done when training the "
"parameters of a :class:`mlx.nn.Module`."
msgstr ""
"當你編譯的函式會更新一個陣列容器時（例如訓練 :class:`mlx.nn.Module` 的參數時"
"常見），這尤其有用。"

#: ../../../src/usage/compile.rst:238
msgid ""
"Compiled functions will also treat any inputs not in the parameter list as "
"constants. For example:"
msgstr "編譯函式也會把不在參數列表中的任何輸入視為常數。例如："

#: ../../../src/usage/compile.rst:241
msgid ""
"state = [mx.array(1.0)]\n"
"\n"
"@mx.compile\n"
"def fun(x):\n"
"    return x + state[0]\n"
"\n"
"# Prints array(2, dtype=float32)\n"
"print(fun(mx.array(1.0)))\n"
"\n"
"# Update state\n"
"state[0] = mx.array(5.0)\n"
"\n"
"# Still prints array(2, dtype=float32)\n"
"print(fun(mx.array(1.0)))"
msgstr ""

#: ../../../src/usage/compile.rst:258
msgid ""
"In order to have the change of state reflected in the outputs of ``fun`` you "
"again have two options. The first option is to simply pass ``state`` as "
"input to the function. In some cases this can be pretty inconvenient. "
"Hence, :func:`compile` also has a parameter to capture implicit inputs:"
msgstr ""

#: ../../../src/usage/compile.rst:263
msgid ""
"from functools import partial\n"
"state = [mx.array(1.0)]\n"
"\n"
"# Tell compile to capture state as an input\n"
"@partial(mx.compile, inputs=state)\n"
"def fun(x):\n"
"    return x + state[0]\n"
"\n"
"# Prints array(2, dtype=float32)\n"
"print(fun(mx.array(1.0)))\n"
"\n"
"# Update state\n"
"state[0] = mx.array(5.0)\n"
"\n"
"# Prints array(6, dtype=float32)\n"
"print(fun(mx.array(1.0)))"
msgstr ""

#: ../../../src/usage/compile.rst:284
msgid "Compiling Training Graphs"
msgstr "編譯訓練圖"

#: ../../../src/usage/compile.rst:286
msgid ""
"This section will step through how to use :func:`compile` with a simple "
"example of a common setup: training a model with :obj:`mlx.nn.Module` using "
"an :obj:`mlx.optimizers.Optimizer` with state. We will show how to compile "
"the full forward, backward, and update with :func:`compile`."
msgstr ""
"本節將以一個常見設定的簡單範例說明如何使用 :func:`compile`：使用 :obj:`mlx."
"nn.Module` 訓練模型，並搭配具有狀態的 :obj:`mlx.optimizers.Optimizer`。我們會"
"示範如何用 :func:`compile` 編譯完整的前向、反向與更新。"

#: ../../../src/usage/compile.rst:291
msgid "To start, here is the simple example without any compilation:"
msgstr "首先，以下是不使用任何編譯的簡單範例："

#: ../../../src/usage/compile.rst:293
msgid ""
"import mlx.core as mx\n"
"import mlx.nn as nn\n"
"import mlx.optimizers as optim\n"
"\n"
"# 4 examples with 10 features each\n"
"x = mx.random.uniform(shape=(4, 10))\n"
"\n"
"# 0, 1 targets\n"
"y = mx.array([0, 1, 0, 1])\n"
"\n"
"# Simple linear model\n"
"model = nn.Linear(10, 1)\n"
"\n"
"# SGD with momentum\n"
"optimizer = optim.SGD(learning_rate=0.1, momentum=0.8)\n"
"\n"
"def loss_fn(model, x, y):\n"
"    logits = model(x).squeeze()\n"
"    return nn.losses.binary_cross_entropy(logits, y)\n"
"\n"
"loss_and_grad_fn = nn.value_and_grad(model, loss_fn)\n"
"\n"
"# Perform 10 steps of gradient descent\n"
"for it in range(10):\n"
"    loss, grads = loss_and_grad_fn(model, x, y)\n"
"    optimizer.update(model, grads)\n"
"    mx.eval(model.parameters(), optimizer.state)"
msgstr ""

#: ../../../src/usage/compile.rst:323
msgid ""
"To compile the update we can put it all in a function and compile it with "
"the appropriate input and output captures. Here's the same example but "
"compiled:"
msgstr ""
"要編譯更新，我們可以把所有步驟包成一個函式，並用適當的輸入與輸出捕捉進行編"
"譯。以下是相同範例的編譯版本："

#: ../../../src/usage/compile.rst:326
msgid ""
"import mlx.core as mx\n"
"import mlx.nn as nn\n"
"import mlx.optimizers as optim\n"
"from functools import partial\n"
"\n"
"# 4 examples with 10 features each\n"
"x = mx.random.uniform(shape=(4, 10))\n"
"\n"
"# 0, 1 targets\n"
"y = mx.array([0, 1, 0, 1])\n"
"\n"
"# Simple linear model\n"
"model = nn.Linear(10, 1)\n"
"\n"
"# SGD with momentum\n"
"optimizer = optim.SGD(learning_rate=0.1, momentum=0.8)\n"
"\n"
"def loss_fn(model, x, y):\n"
"    logits = model(x).squeeze()\n"
"    return nn.losses.binary_cross_entropy(logits, y)\n"
"\n"
"# The state that will be captured as input and output\n"
"state = [model.state, optimizer.state]\n"
"\n"
"@partial(mx.compile, inputs=state, outputs=state)\n"
"def step(x, y):\n"
"    loss_and_grad_fn = nn.value_and_grad(model, loss_fn)\n"
"    loss, grads = loss_and_grad_fn(model, x, y)\n"
"    optimizer.update(model, grads)\n"
"    return loss\n"
"\n"
"# Perform 10 steps of gradient descent\n"
"for it in range(10):\n"
"    loss = step(x, y)\n"
"    # Evaluate the model and optimizer state\n"
"    mx.eval(state)\n"
"    print(loss)"
msgstr ""

#: ../../../src/usage/compile.rst:369
msgid ""
"If you are using a module which performs random sampling such as :func:`mlx."
"nn.Dropout`, make sure you also include ``mx.random.state`` in the ``state`` "
"captured by :func:`compile`, i.e. ``state = [model.state, optimizer.state, "
"mx.random.state]``."
msgstr ""
"如果你使用會進行隨機取樣的模組（例如 :func:`mlx.nn.Dropout`），請確保也把 "
"``mx.random.state`` 納入 :func:`compile` 捕捉的 ``state``，即 ``state = "
"[model.state, optimizer.state, mx.random.state]``。"

#: ../../../src/usage/compile.rst:377
msgid ""
"For more examples of compiling full training graphs checkout the  `MLX "
"Examples <https://github.com/ml-explore/mlx-examples>`_ GitHub repo."
msgstr ""
"更多完整訓練圖編譯範例請參考 `MLX Examples <https://github.com/ml-explore/"
"mlx-examples>`_ GitHub 專案。"

#: ../../../src/usage/compile.rst:381
msgid "Transformations with Compile"
msgstr "與 Compile 搭配的變換"

#: ../../../src/usage/compile.rst:383
msgid ""
"In MLX function transformations are composable. You can apply any function "
"transformation to the output of any other function transformation. For more "
"on this, see the documentation on :ref:`function transforms "
"<function_transforms>`."
msgstr ""
"在 MLX 中，函式變換可以組合使用。你可以把任何函式變換套用到其他函式變換的輸"
"出。詳情請參考 :ref:`function transforms <function_transforms>` 的文件。"

#: ../../../src/usage/compile.rst:388
msgid "Compiling transformed functions works just as expected:"
msgstr "編譯變換後的函式會如預期般運作："

#: ../../../src/usage/compile.rst:390
msgid ""
"grad_fn = mx.grad(mx.exp)\n"
"\n"
"compiled_grad_fn = mx.compile(grad_fn)\n"
"\n"
"# Prints: array(2.71828, dtype=float32)\n"
"print(grad_fn(mx.array(1.0)))\n"
"\n"
"# Also prints: array(2.71828, dtype=float32)\n"
"print(compiled_grad_fn(mx.array(1.0)))"
msgstr ""

#: ../../../src/usage/compile.rst:404
msgid ""
"In order to compile as much as possible, a transformation of a compiled "
"function will not by default be compiled. To compile the transformed "
"function simply pass it through :func:`compile`."
msgstr ""
"為了盡可能多地編譯，對已編譯函式的變換，預設不會再被編譯。若要編譯變換後的函"
"式，只需再通過 :func:`compile`。"

#: ../../../src/usage/compile.rst:408
msgid ""
"You can also compile functions which themselves call compiled functions. A "
"good practice is to compile the outer most function to give :func:`compile` "
"the most opportunity to optimize the computation graph:"
msgstr ""
"你也可以編譯會呼叫已編譯函式的函式。最佳做法是編譯最外層函式，讓 :func:"
"`compile` 有最多機會最佳化計算圖："

#: ../../../src/usage/compile.rst:412
msgid ""
"@mx.compile\n"
"def inner(x):\n"
"    return mx.exp(-mx.abs(x))\n"
"\n"
"def outer(x):\n"
"    inner(inner(x))\n"
"\n"
"# Compiling the outer function is good to do as it will likely\n"
"# be faster even though the inner functions are compiled\n"
"fun = mx.compile(outer)"
msgstr ""

#: ../../../src/usage/compile.rst:430
msgid "Shapeless Compilation"
msgstr "無形狀編譯"

#: ../../../src/usage/compile.rst:432
msgid ""
"When the shape of an input to a compiled function changes, the function is "
"recompiled. You can compile a function once and run it on inputs with "
"variable shapes by specifying ``shapeless=True`` to :func:`compile`. In this "
"case changes to the shapes of the inputs do not cause the function to be "
"recompiled."
msgstr ""
"當已編譯函式的輸入形狀改變時，函式會重新編譯。你可以在 :func:`compile` 指定 "
"``shapeless=True``，只編譯一次並可用於可變形狀的輸入。在此情況下，輸入形狀變"
"更不會觸發重新編譯。"

#: ../../../src/usage/compile.rst:438
msgid ""
"def fun(x, y):\n"
"    return mx.abs(x + y)\n"
"\n"
"compiled_fun = mx.compile(fun, shapeless=True)\n"
"\n"
"x = mx.array(1.0)\n"
"y = mx.array(-2.0)\n"
"\n"
"# Firt call compiles the function\n"
"print(compiled_fun(x, y))\n"
"\n"
"# Second call with different shapes\n"
"# does not recompile the function\n"
"x = mx.array([1.0, -6.0])\n"
"y = mx.array([-2.0, 3.0])\n"
"print(compiled_fun(x, y))"
msgstr ""

#: ../../../src/usage/compile.rst:458
msgid ""
"Use shapeless compilations carefully. Since compilation is not triggered "
"when shapes change, any graphs which are conditional on the input shapes "
"will not work as expected. Shape-dependent computations are common and "
"sometimes subtle to detect. For example:"
msgstr ""
"請謹慎使用無形狀編譯。因為形狀變更不會觸發編譯，任何依賴輸入形狀的圖都可能無"
"法如預期運作。形狀相依的計算很常見，有時也不易察覺。例如："

#: ../../../src/usage/compile.rst:463
msgid ""
"def fun(x):\n"
"    return x.reshape(x.shape[0] * x.shape[1], -1)\n"
"\n"
"compiled_fun = mx.compile(fun, shapeless=True)\n"
"\n"
"x = mx.random.uniform(shape=(2, 3, 4))\n"
"\n"
"out = compiled_fun(x)\n"
"\n"
"x = mx.random.uniform(shape=(5, 5, 3))\n"
"\n"
"# Error, can't reshape (5, 5, 3) to (6, -1)\n"
"out = compiled_fun(x)"
msgstr ""

#: ../../../src/usage/compile.rst:479
msgid ""
"The second call to the ``compiled_fun`` fails because of the call to :func:"
"`reshape` which uses the static shape of ``x`` in the first call. We can fix "
"this by using :func:`flatten` to avoid hardcoding the shape of ``x``:"
msgstr ""
"第二次呼叫 ``compiled_fun`` 會失敗，因為 :func:`reshape` 使用了第一次呼叫時 "
"``x`` 的靜態形狀。我們可以改用 :func:`flatten` 來避免硬編碼 ``x`` 的形狀："

#: ../../../src/usage/compile.rst:483
msgid ""
"def fun(x):\n"
"    return x.flatten(0, 1)\n"
"\n"
"compiled_fun = mx.compile(fun, shapeless=True)\n"
"\n"
"x = mx.random.uniform(shape=(2, 3, 4))\n"
"\n"
"out = compiled_fun(x)\n"
"\n"
"x = mx.random.uniform(shape=(5, 5, 3))\n"
"\n"
"# Ok\n"
"out = compiled_fun(x)"
msgstr ""
