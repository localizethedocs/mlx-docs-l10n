# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, MLX Contributors
# This file is distributed under the same license as the MLX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MLX 0.22\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-08 12:45+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../src/usage/indexing.rst:4
msgid "Indexing Arrays"
msgstr ""

#: ../../../src/usage/indexing.rst:8
msgid ""
"For the most part, indexing an MLX :obj:`array` works the same as indexing a "
"NumPy :obj:`numpy.ndarray`. See the `NumPy documentation <https://numpy.org/"
"doc/stable/user/basics.indexing.html>`_ for more details on how that works."
msgstr ""

#: ../../../src/usage/indexing.rst:13
msgid ""
"For example, you can use regular integers and slices (:obj:`slice`) to index "
"arrays:"
msgstr ""

#: ../../../src/usage/indexing.rst:15
msgid ""
">>> arr = mx.arange(10)\n"
">>> arr[3]\n"
"array(3, dtype=int32)\n"
">>> arr[-2]  # negative indexing works\n"
"array(8, dtype=int32)\n"
">>> arr[2:8:2] # start, stop, stride\n"
"array([2, 4, 6], dtype=int32)"
msgstr ""

#: ../../../src/usage/indexing.rst:25
msgid ""
"For multi-dimensional arrays, the ``...`` or :obj:`Ellipsis` syntax works as "
"in NumPy:"
msgstr ""

#: ../../../src/usage/indexing.rst:27
msgid ""
">>> arr = mx.arange(8).reshape(2, 2, 2)\n"
">>> arr[:, :, 0]\n"
"array(3, dtype=int32)\n"
"array([[0, 2],\n"
"       [4, 6]], dtype=int32\n"
">>> arr[..., 0]\n"
"array([[0, 2],\n"
"       [4, 6]], dtype=int32"
msgstr ""

#: ../../../src/usage/indexing.rst:38
msgid "You can index with ``None`` to create a new axis:"
msgstr ""

#: ../../../src/usage/indexing.rst:40
msgid ""
">>> arr = mx.arange(8)\n"
">>> arr.shape\n"
"[8]\n"
">>> arr[None].shape\n"
"[1, 8]"
msgstr ""

#: ../../../src/usage/indexing.rst:49
msgid "You can also use an :obj:`array` to index another :obj:`array`:"
msgstr ""

#: ../../../src/usage/indexing.rst:51
msgid ""
">>> arr = mx.arange(10)\n"
">>> idx = mx.array([5, 7])\n"
">>> arr[idx]\n"
"array([5, 7], dtype=int32)"
msgstr ""

#: ../../../src/usage/indexing.rst:58
msgid ""
"Mixing and matching integers, :obj:`slice`, ``...``, and :obj:`array` "
"indices works just as in NumPy."
msgstr ""

#: ../../../src/usage/indexing.rst:61
msgid ""
"Other functions which may be useful for indexing arrays are :func:`take` "
"and :func:`take_along_axis`."
msgstr ""

#: ../../../src/usage/indexing.rst:65
msgid "Differences from NumPy"
msgstr ""

#: ../../../src/usage/indexing.rst:69
msgid "MLX indexing is different from NumPy indexing in two important ways:"
msgstr ""

#: ../../../src/usage/indexing.rst:71
msgid ""
"Indexing does not perform bounds checking. Indexing out of bounds is "
"undefined behavior."
msgstr ""

#: ../../../src/usage/indexing.rst:73
msgid "Boolean mask based indexing is not yet supported."
msgstr ""

#: ../../../src/usage/indexing.rst:75
msgid ""
"The reason for the lack of bounds checking is that exceptions cannot "
"propagate from the GPU. Performing bounds checking for array indices before "
"launching the kernel would be extremely inefficient."
msgstr ""

#: ../../../src/usage/indexing.rst:79
msgid ""
"Indexing with boolean masks is something that MLX may support in the future. "
"In general, MLX has limited support for operations for which output *shapes* "
"are dependent on input *data*. Other examples of these types of operations "
"which MLX does not yet support include :func:`numpy.nonzero` and the single "
"input version of :func:`numpy.where`."
msgstr ""

#: ../../../src/usage/indexing.rst:86
msgid "In Place Updates"
msgstr ""

#: ../../../src/usage/indexing.rst:88
msgid "In place updates to indexed arrays are possible in MLX. For example:"
msgstr ""

#: ../../../src/usage/indexing.rst:90
msgid ""
">>> a = mx.array([1, 2, 3])\n"
">>> a[2] = 0\n"
">>> a\n"
"array([1, 2, 0], dtype=int32)"
msgstr ""

#: ../../../src/usage/indexing.rst:97
msgid ""
"Just as in NumPy, in place updates will be reflected in all references to "
"the same array:"
msgstr ""

#: ../../../src/usage/indexing.rst:100
msgid ""
">>> a = mx.array([1, 2, 3])\n"
">>> b = a\n"
">>> b[2] = 0\n"
">>> b\n"
"array([1, 2, 0], dtype=int32)\n"
">>> a\n"
"array([1, 2, 0], dtype=int32)"
msgstr ""

#: ../../../src/usage/indexing.rst:110
msgid ""
"Transformations of functions which use in-place updates are allowed and work "
"as expected. For example:"
msgstr ""

#: ../../../src/usage/indexing.rst:113
msgid ""
"def fun(x, idx):\n"
"    x[idx] = 2.0\n"
"    return x.sum()\n"
"\n"
"dfdx = mx.grad(fun)(mx.array([1.0, 2.0, 3.0]), mx.array([1]))\n"
"print(dfdx)  # Prints: array([1, 0, 1], dtype=float32)"
msgstr ""

#: ../../../src/usage/indexing.rst:122
msgid ""
"In the above ``dfdx`` will have the correct gradient, namely zeros at "
"``idx`` and ones elsewhere."
msgstr ""
