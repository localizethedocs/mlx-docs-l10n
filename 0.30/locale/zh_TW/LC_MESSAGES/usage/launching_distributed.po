# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Apple
# This file is distributed under the same license as the MLX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MLX 0.30\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-23 09:21+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../src/usage/launching_distributed.rst:6
msgid "Launching Distributed Programs"
msgstr "啟動分散式程式"

#: ../../../src/usage/launching_distributed.rst:10
msgid ""
"The MLX python package provides two utilities to help you configure your "
"Macs for distributed computation and also launch distributed programs on "
"multiple nodes or with many processes in a single node. These utilities are "
"aptly named"
msgstr ""
"MLX Python 軟體包提供兩個工具，協助你設定 Mac 以進行分散式計算，並在多個節點"
"或單一節點的多個行程上啟動分散式程式。這兩個工具分別是"

#: ../../../src/usage/launching_distributed.rst:14
#: ../../../src/usage/launching_distributed.rst:109
msgid "``mlx.launch``"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:15
#: ../../../src/usage/launching_distributed.rst:21
msgid "``mlx.distributed_config``"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:17
msgid ""
"See the :doc:`distributed docs <distributed>` for an introduction and "
"getting-started guides to the various backends."
msgstr ""
"各種後端的入門與新手指南，請參閱 :doc:`distributed 文件 <distributed>`。"

#: ../../../src/usage/launching_distributed.rst:23
msgid ""
"Unless you are launching distributed jobs locally for development or multi-"
"gpu CUDA environments, then you have several Macs that you need to configure "
"for distributed communication with MLX."
msgstr ""
"除非你只是在本機用於開發或多 GPU 的 CUDA 環境啟動分散式工作，否則你會有多台 "
"Mac 需要設定為可與 MLX 進行分散式通訊。"

#: ../../../src/usage/launching_distributed.rst:27
msgid ""
"``mlx.distributed_config`` aims to automate the process of configuring the "
"network interfaces (especially for communication over thunderbolt) and also "
"creating the hostfile to be used with ``mlx.launch``."
msgstr ""
"``mlx.distributed_config`` 旨在自動化設定網路介面（特別是 Thunderbolt 通訊）"
"以及建立供 ``mlx.launch`` 使用的 hostfile。"

#: ../../../src/usage/launching_distributed.rst:31
msgid "We will analyse 3 cases of using ``mlx.distributed_config``"
msgstr "我們將分析使用 ``mlx.distributed_config`` 的 3 種情況"

#: ../../../src/usage/launching_distributed.rst:33
msgid "RDMA over thunderbolt using JACCL"
msgstr "使用 JACCL 的 Thunderbolt RDMA"

#: ../../../src/usage/launching_distributed.rst:34
msgid "TCP/IP over thunderbolt using the ring backend"
msgstr "使用 ring 後端的 Thunderbolt TCP/IP"

#: ../../../src/usage/launching_distributed.rst:35
msgid "TCP/IP over ethernet using the ring backend"
msgstr "使用 ring 後端的 Ethernet TCP/IP"

#: ../../../src/usage/launching_distributed.rst:38
msgid "JACCL"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:40
msgid ""
"After following :ref:`the steps to enable RDMA <jaccl_section>` you can run "
"the following command to configure the nodes and create the hostfile."
msgstr ""
"依照 :ref:`啟用 RDMA 的步驟 <jaccl_section>` 完成後，你可以執行以下命令來設定"
"節點並建立 hostfile。"

#: ../../../src/usage/launching_distributed.rst:43
msgid ""
"mlx.distributed_config --verbose --backend jaccl \\\n"
"     --hosts m3-ultra-1,m3-ultra-2,m3-ultra-3,m3-ultra-4 --over thunderbolt "
"\\\n"
"     --auto-setup --output m3-ultra-jaccl.json"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:49
msgid ""
"Let's walk through the steps that the script takes to configure the nodes."
msgstr "讓我們逐步看看這個腳本設定節點時會做哪些步驟。"

#: ../../../src/usage/launching_distributed.rst:51
msgid "ssh to all nodes to verify that they are reachable"
msgstr "ssh 到所有節點以確認可以連線"

#: ../../../src/usage/launching_distributed.rst:52
msgid ""
"Extract the thunderbolt connectivity. Namely run commands on each node to "
"calculate which node is connected to which other node."
msgstr ""
"取得 Thunderbolt 連線拓撲，也就是在每個節點上執行命令以計算節點之間的連線關"
"係。"

#: ../../../src/usage/launching_distributed.rst:54
msgid "Verify that we have a valid fully connected mesh"
msgstr "確認我們有有效的完整連通 mesh"

#: ../../../src/usage/launching_distributed.rst:55
msgid "Check that RDMA is enabled"
msgstr "確認 RDMA 已啟用"

#: ../../../src/usage/launching_distributed.rst:56
msgid "Extract the ethernet IP from interface en0"
msgstr "從介面 en0 取得 Ethernet IP"

#: ../../../src/usage/launching_distributed.rst:57
msgid ""
"Disable the thunderbolt bridge and set up peer to peer networks for each "
"thunderbolt cable"
msgstr "停用 Thunderbolt bridge，並為每條 Thunderbolt 纜線建立點對點網路"

#: ../../../src/usage/launching_distributed.rst:59
msgid "Write the hostfile"
msgstr "寫入 hostfile"

#: ../../../src/usage/launching_distributed.rst:61
msgid ""
"Knowing the above steps allows you to manually configure the nodes but also "
"debug any configuration issue. For instance changing the Ethernet IP to a "
"different interface directly in the config is possible (as long as it is "
"reachable from all nodes)."
msgstr ""
"了解上述步驟可以讓你手動設定節點，並排除任何設定問題。例如，你可以在設定檔中"
"把 Ethernet IP 改成其他介面（只要所有節點都能連到即可）。"

#: ../../../src/usage/launching_distributed.rst:66
msgid ""
"The ``--auto-setup`` argument requires password-less sudo on each node. If "
"it isn't available then the configuration script will print commands to be "
"run on each node."
msgstr ""
"``--auto-setup`` 參數需要每個節點具備無密碼 sudo。若不可用，設定腳本會列印需"
"要在各節點執行的命令。"

#: ../../../src/usage/launching_distributed.rst:71
msgid "Ring over thunderbolt"
msgstr "Thunderbolt 上的 Ring"

#: ../../../src/usage/launching_distributed.rst:73
msgid ""
"Setting up a ring backend over thunderbolt only requires changing the ``--"
"backend`` from ``jaccl`` to ``ring``."
msgstr ""
"在 Thunderbolt 上設定 ring 後端，只需將 ``--backend`` 從 ``jaccl`` 改為 "
"``ring``。"

#: ../../../src/usage/launching_distributed.rst:76
msgid ""
"The steps are very similar with the main difference being that instead of "
"verifying that the nodes are fully connected, the script attempts to "
"identify a ring topology (or multiple rings)."
msgstr ""
"步驟非常相似，主要差異在於腳本不再驗證節點是否完整連通，而是嘗試辨識 ring 拓"
"撲（或多個 ring）。"

#: ../../../src/usage/launching_distributed.rst:81
msgid "Ring over Ethernet"
msgstr "Ethernet 上的 Ring"

#: ../../../src/usage/launching_distributed.rst:83
msgid ""
"Configuring the ring backend over ethernet doesn't require setting up "
"network interface and as such it simply extracts the ``en0`` IP from each "
"node and writes the hostfile."
msgstr ""
"在 Ethernet 上設定 ring 後端不需要設定網路介面，因此它只會從每個節點取得 "
"``en0`` 的 IP 並寫入 hostfile。"

#: ../../../src/usage/launching_distributed.rst:88
msgid "Debugging cable connections"
msgstr "除錯纜線連線"

#: ../../../src/usage/launching_distributed.rst:90
msgid ""
"``mlx.distributed_config`` can help you debug the connectivity of your nodes "
"over thunderbolt by exporting a graph of the connections."
msgstr ""
"``mlx.distributed_config`` 可藉由匯出連線圖來協助你除錯 Thunderbolt 節點的連"
"線情況。"

#: ../../../src/usage/launching_distributed.rst:93
msgid "Running"
msgstr "執行"

#: ../../../src/usage/launching_distributed.rst:95
msgid ""
"mlx.distributed_config --verbose \\\n"
"     --hosts host1,host2,host3,host4 \\\n"
"     --over thunderbolt --dot"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:101
msgid ""
"will export a `GraphViz <https://graphviz.org>`_ representation of the "
"connections between the nodes which makes it very easy to figure out which "
"cable is not connected correctly."
msgstr ""
"會輸出節點間連線的 `GraphViz <https://graphviz.org>`_ 表示法，讓你很容易判斷"
"哪條纜線沒有正確連接。"

#: ../../../src/usage/launching_distributed.rst:105
msgid "See :ref:`the JACCL section <jaccl_section>` for an example."
msgstr "範例請見 :ref:`JACCL 章節 <jaccl_section>`。"

#: ../../../src/usage/launching_distributed.rst:111
msgid "The minimal usage example of ``mlx.launch`` is simply"
msgstr "``mlx.launch`` 的最小使用範例如下"

#: ../../../src/usage/launching_distributed.rst:113
msgid "mlx.launch --hosts ip1,ip2 my_script.py"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:117
msgid "or for testing on localhost"
msgstr "或用於在 localhost 測試"

#: ../../../src/usage/launching_distributed.rst:119
msgid "mlx.launch -n 2 my_script.py"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:123
msgid ""
"The ``mlx.launch`` command connects to the provided host and launches the "
"input script on each host. It monitors each of the launched processes and "
"terminates the rest if one of them fails unexpectedly or if ``mlx.launch`` "
"is terminated. It also takes care of forwarding the output of each remote "
"process to stdout and stderr respectively."
msgstr ""
"``mlx.launch`` 會連線到指定的主機並在每台主機上啟動輸入腳本。它會監控每個已啟"
"動的行程，若其中一個意外失敗或 ``mlx.launch`` 被終止，則會結束其餘行程。它也"
"會負責將每個遠端行程的輸出分別轉送到 stdout 與 stderr。"

#: ../../../src/usage/launching_distributed.rst:129
msgid ""
"Importantly, it also broadcasts stdin to each process which enables "
"interactive programs to work in distributed mode as well as debugging using "
"the interactive debugger."
msgstr ""
"更重要的是，它也會將 stdin 廣播到每個行程，讓互動式程式能在分散式模式下運作，"
"並可使用互動式除錯器進行除錯。"

#: ../../../src/usage/launching_distributed.rst:134
msgid "Providing Hosts"
msgstr "提供主機"

#: ../../../src/usage/launching_distributed.rst:136
msgid ""
"Hosts can be provided as command line arguments, like above, but the way "
"that allows to fully define a list of hosts is via a JSON hostfile. The "
"hostfile has a very simple schema. It is simply a list of objects that "
"define each host via a hostname to ssh to and a list of IPs to utilize for "
"the communication."
msgstr ""
"主機可以像上面一樣以命令列參數提供，但要完整定義主機清單，建議使用 JSON "
"hostfile。hostfile 的格式很簡單，就是一個物件列表，每個物件定義一個可用於 "
"ssh 的主機名稱，以及用於通訊的一組 IP。"

#: ../../../src/usage/launching_distributed.rst:141
msgid ""
"[\n"
"    {\"ssh\": \"hostname1\", \"ips\": [\"123.123.1.1\", \"123.123.2.1\"]},\n"
"    {\"ssh\": \"hostname2\", \"ips\": [\"123.123.1.2\", \"123.123.2.2\"]}\n"
"]"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:148
msgid ""
"You can use ``mlx.distributed_config --over ethernet`` to create a hostfile "
"with IPs corresponding to the ``en0`` interface."
msgstr ""
"你可以使用 ``mlx.distributed_config --over ethernet`` 建立以 ``en0`` 介面 IP "
"為內容的 hostfile。"

#: ../../../src/usage/launching_distributed.rst:152
msgid "Setting up Remote Hosts"
msgstr "設定遠端主機"

#: ../../../src/usage/launching_distributed.rst:154
msgid ""
"In order to be able to launch the script on each host we need to be able to "
"connect via ssh. Moreover the input script and python binary need to be on "
"each host and on the same path. A good checklist to debug errors is the "
"following:"
msgstr ""
"為了能在每個主機上啟動腳本，我們必須能透過 ssh 連線。此外，輸入腳本與 Python "
"可執行檔必須在每個主機上，且路徑相同。以下是除錯時的檢查清單："

#: ../../../src/usage/launching_distributed.rst:158
msgid "``ssh hostname`` works without asking for password or host confirmation"
msgstr "``ssh hostname`` 不會要求密碼或主機確認"

#: ../../../src/usage/launching_distributed.rst:159
msgid ""
"the python binary is available on all hosts at the same path. You can use "
"``mlx.launch --print-python`` to see what that path is."
msgstr ""
"Python 可執行檔在所有主機上的路徑相同。你可以用 ``mlx.launch --print-"
"python`` 查看該路徑。"

#: ../../../src/usage/launching_distributed.rst:161
msgid "the script you want to run is available on all hosts at the same path"
msgstr "要執行的腳本在所有主機上的路徑相同"

#: ../../../src/usage/launching_distributed.rst:163
msgid ""
"If you are launching from a node with a completely different setup than the "
"nodes that the program will run on, you can specify ``--no-verify-script`` "
"so that ``mlx.launch`` does not attempt to verify that the executable and "
"script exist locally before launching the distributed job."
msgstr ""
"如果你從與實際執行節點環境完全不同的主機啟動，可以指定 ``--no-verify-"
"script``，讓 ``mlx.launch`` 不在啟動分散式工作前檢查本機是否存在可執行檔與腳"
"本。"

#: ../../../src/usage/launching_distributed.rst:171
msgid "Ring Specifics"
msgstr "Ring 的注意事項"

#: ../../../src/usage/launching_distributed.rst:173
msgid ""
"The :ref:`ring <ring_section>` backend, which is also the default backend, "
"can be explicitly selected with the argument ``--backend ring``. The ring "
"backend has some specific requirements and arguments that are different to "
"other backends:"
msgstr ""
":ref:`ring <ring_section>` 後端也是預設後端，可用 ``--backend ring`` 明確指"
"定。ring 後端有一些與其他後端不同的特殊需求與參數："

#: ../../../src/usage/launching_distributed.rst:178
msgid ""
"The argument ``--hosts`` only accepts IPs and not hostnames. If we need to "
"ssh to a hostname that does not correspond to the IP we want to bind to we "
"have to provide a hostfile."
msgstr ""
"``--hosts`` 參數只接受 IP，不接受主機名稱。若需要 ssh 到的主機名稱不對應你要"
"綁定的 IP，就必須提供 hostfile。"

#: ../../../src/usage/launching_distributed.rst:181
msgid ""
"``--starting-port`` defines the port to bind to on the remote hosts. "
"Specifically rank 0 for the first IP will use this port and each subsequent "
"IP or rank will add 1 to this port."
msgstr ""
"``--starting-port`` 定義在遠端主機上要綁定的連接埠。第一個 IP 的 rank 0 會使"
"用此連接埠，後續每個 IP 或 rank 會在此基礎上加 1。"

#: ../../../src/usage/launching_distributed.rst:184
msgid ""
"``--connections-per-ip`` allows us to increase the number of connections "
"between neighboring nodes. This corresponds to ``--mca btl_tcp_links 2`` for "
"``mpirun``."
msgstr ""
"``--connections-per-ip`` 可增加相鄰節點之間的連線數量。這相當於 ``mpirun`` "
"的 ``--mca btl_tcp_links 2``。"

#: ../../../src/usage/launching_distributed.rst:191
msgid "JACCL Specifics"
msgstr "JACCL 的注意事項"

#: ../../../src/usage/launching_distributed.rst:193
msgid ""
"The :ref:`JACCL <jaccl_section>` backend can be selected with the argument "
"``--backend jaccl``. A hostfile is necessary to launch with this backend "
"because it needs to contain the RDMA devices connecting each node to each "
"other node."
msgstr ""
":ref:`JACCL <jaccl_section>` 後端可用 ``--backend jaccl`` 指定。使用此後端啟"
"動必須提供 hostfile，因為其中需要包含各節點彼此連線的 RDMA 裝置資訊。"

#: ../../../src/usage/launching_distributed.rst:199
msgid "NCCL Specifics"
msgstr "NCCL 的注意事項"

#: ../../../src/usage/launching_distributed.rst:201
msgid ""
"The :ref:`NCCL <nccl_section>` backend is the default backend for CUDA "
"environments. When launching from a Mac to a Linux machine with CUDA then "
"the backend should be selected using ``--backend nccl``."
msgstr ""
":ref:`NCCL <nccl_section>` 後端是 CUDA 環境的預設後端。當從 Mac 啟動到具 "
"CUDA 的 Linux 主機時，應使用 ``--backend nccl`` 指定後端。"

#: ../../../src/usage/launching_distributed.rst:205
msgid ""
"The ``--repeat-hosts, -n`` argument should be used to launch multi-node and "
"multi-gpu jobs. For instance"
msgstr "``--repeat-hosts, -n`` 參數應用於啟動多節點、多 GPU 的工作。例如："

#: ../../../src/usage/launching_distributed.rst:208
msgid ""
"mlx.launch --backend nccl --hosts linux-1,linux-2 -n 8 --no-verify-script "
"-- ./my-job.sh"
msgstr ""

#: ../../../src/usage/launching_distributed.rst:212
msgid ""
"will attempt to launch 16 processes, 8 on each node that will all run ``my-"
"job.sh``."
msgstr "會嘗試啟動 16 個行程，每個節點 8 個，全部執行 ``my-job.sh``。"

#: ../../../src/usage/launching_distributed.rst:218
msgid "MPI Specifics"
msgstr "MPI 的注意事項"

#: ../../../src/usage/launching_distributed.rst:220
msgid ""
"One can use MPI by passing ``--backend mpi`` to ``mlx.launch``. In that "
"case, ``mlx.launch`` is a thin wrapper over ``mpirun``. Moreover,"
msgstr ""
"可透過對 ``mlx.launch`` 傳入 ``--backend mpi`` 來使用 MPI。在此情況下，``mlx."
"launch`` 只是 ``mpirun`` 的薄包裝。此外："

#: ../../../src/usage/launching_distributed.rst:223
msgid "The IPs in the hostfile are ignored"
msgstr "hostfile 中的 IP 會被忽略"

#: ../../../src/usage/launching_distributed.rst:224
msgid ""
"The ssh connectivity requirement is stronger as every node needs to be able "
"to connect to every other node"
msgstr "ssh 連線要求更嚴格，因為每個節點都必須能連到所有其他節點"

#: ../../../src/usage/launching_distributed.rst:226
msgid "``mpirun`` needs to be available on every node at the same path"
msgstr "``mpirun`` 必須在每個節點上以相同路徑存在"

#: ../../../src/usage/launching_distributed.rst:228
msgid ""
"Finally, one can pass arguments to ``mpirun`` using ``--mpi-arg``. For "
"instance to choose a specific interface for the byte-transfer-layer of MPI "
"we can call ``mlx.launch`` as follows:"
msgstr ""
"最後，你可以使用 ``--mpi-arg`` 將參數傳給 ``mpirun``。例如，若要為 MPI 的 "
"byte-transfer-layer 選擇特定介面，可以如下呼叫 ``mlx.launch``："

#: ../../../src/usage/launching_distributed.rst:232
msgid ""
"mlx.launch --backend mpi --mpi-arg '--mca btl_tcp_if_include en0' --hostfile "
"hosts.json my_script.py"
msgstr ""
