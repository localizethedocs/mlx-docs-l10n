# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2023, Apple
# This file is distributed under the same license as the MLX package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MLX 0.27\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-12-08 12:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../src/usage/export.rst:4
msgid "Exporting Functions"
msgstr ""

#: ../../../src/usage/export.rst:8
msgid ""
"MLX has an API to export and import functions to and from a file. This lets "
"you run computations written in one MLX front-end (e.g. Python) in another "
"MLX front-end (e.g. C++)."
msgstr ""

#: ../../../src/usage/export.rst:12
msgid ""
"This guide walks through the basics of the MLX export API with some "
"examples. To see the full list of functions check-out the :ref:`API "
"documentation <export>`."
msgstr ""

#: ../../../src/usage/export.rst:17
msgid "Basics of Exporting"
msgstr ""

#: ../../../src/usage/export.rst:19
msgid "Let's start with a simple example:"
msgstr ""

#: ../../../src/usage/export.rst:21
msgid ""
"def fun(x, y):\n"
"  return x + y\n"
"\n"
"x = mx.array(1.0)\n"
"y = mx.array(1.0)\n"
"mx.export_function(\"add.mlxfn\", fun, x, y)"
msgstr ""

#: ../../../src/usage/export.rst:30
msgid ""
"To export a function, provide sample input arrays that the function can be "
"called with. The data doesn't matter, but the shapes and types of the arrays "
"do. In the above example we exported ``fun`` with two ``float32`` scalar "
"arrays. We can then import the function and run it:"
msgstr ""

#: ../../../src/usage/export.rst:35
msgid ""
"add_fun = mx.import_function(\"add.mlxfn\")\n"
"\n"
"out, = add_fun(mx.array(1.0), mx.array(2.0))\n"
"# Prints: array(3, dtype=float32)\n"
"print(out)\n"
"\n"
"out, = add_fun(mx.array(1.0), mx.array(3.0))\n"
"# Prints: array(4, dtype=float32)\n"
"print(out)\n"
"\n"
"# Raises an exception\n"
"add_fun(mx.array(1), mx.array(3.0))\n"
"\n"
"# Raises an exception\n"
"add_fun(mx.array([1.0, 2.0]), mx.array(3.0))"
msgstr ""

#: ../../../src/usage/export.rst:53
msgid ""
"Notice the third and fourth calls to ``add_fun`` raise exceptions because "
"the shapes and types of the inputs are different than the shapes and types "
"of the example inputs we exported the function with."
msgstr ""

#: ../../../src/usage/export.rst:57
msgid ""
"Also notice that even though the original ``fun`` returns a single output "
"array, the imported function always returns a tuple of one or more arrays."
msgstr ""

#: ../../../src/usage/export.rst:60
msgid ""
"The inputs to :func:`export_function` and to an imported function can be "
"specified as variable positional arguments or as a tuple of arrays:"
msgstr ""

#: ../../../src/usage/export.rst:63
msgid ""
"def fun(x, y):\n"
"  return x + y\n"
"\n"
"x = mx.array(1.0)\n"
"y = mx.array(1.0)\n"
"\n"
"# Both arguments to fun are positional\n"
"mx.export_function(\"add.mlxfn\", fun, x, y)\n"
"\n"
"# Same as above\n"
"mx.export_function(\"add.mlxfn\", fun, (x, y))\n"
"\n"
"imported_fun = mx.import_function(\"add.mlxfn\")\n"
"\n"
"# Ok\n"
"out, = imported_fun(x, y)\n"
"\n"
"# Also ok\n"
"out, = imported_fun((x, y))"
msgstr ""

#: ../../../src/usage/export.rst:85
msgid ""
"You can pass example inputs to functions as positional or keyword arguments. "
"If you use keyword arguments to export the function, then you have to use "
"the same keyword arguments when calling the imported function."
msgstr ""

#: ../../../src/usage/export.rst:89
msgid ""
"def fun(x, y):\n"
"  return x + y\n"
"\n"
"# One argument to fun is positional, the other is a kwarg\n"
"mx.export_function(\"add.mlxfn\", fun, x, y=y)\n"
"\n"
"imported_fun = mx.import_function(\"add.mlxfn\")\n"
"\n"
"# Ok\n"
"out, = imported_fun(x, y=y)\n"
"\n"
"# Also ok\n"
"out, = imported_fun((x,), {\"y\": y})\n"
"\n"
"# Raises since the keyword argument is missing\n"
"out, = imported_fun(x, y)\n"
"\n"
"# Raises since the keyword argument has the wrong key\n"
"out, = imported_fun(x, z=y)"
msgstr ""

#: ../../../src/usage/export.rst:113
msgid "Exporting Modules"
msgstr ""

#: ../../../src/usage/export.rst:115
msgid ""
"An :obj:`mlx.nn.Module` can be exported with or without the parameters "
"included in the exported function. Here's an example:"
msgstr ""

#: ../../../src/usage/export.rst:118
msgid ""
"model = nn.Linear(4, 4)\n"
"mx.eval(model.parameters())\n"
"\n"
"def call(x):\n"
"   return model(x)\n"
"\n"
"mx.export_function(\"model.mlxfn\", call, mx.zeros(4))"
msgstr ""

#: ../../../src/usage/export.rst:128
msgid ""
"In the above example, the :obj:`mlx.nn.Linear` module is exported. Its "
"parameters are also saved to the ``model.mlxfn`` file."
msgstr ""

#: ../../../src/usage/export.rst:133
msgid ""
"For enclosed arrays inside an exported function, be extra careful to ensure "
"they are evaluated. The computation graph that gets exported will include "
"the computation that produces enclosed inputs."
msgstr ""

#: ../../../src/usage/export.rst:137
msgid ""
"If the above example was missing ``mx.eval(model.parameters()``, the "
"exported function would include the random initialization of the :obj:`mlx."
"nn.Module` parameters."
msgstr ""

#: ../../../src/usage/export.rst:141
msgid ""
"If you only want to export the ``Module.__call__`` function without the "
"parameters, pass them as inputs to the ``call`` wrapper:"
msgstr ""

#: ../../../src/usage/export.rst:144
msgid ""
"model = nn.Linear(4, 4)\n"
"mx.eval(model.parameters())\n"
"\n"
"def call(x, **params):\n"
"  # Set the model's parameters to the input parameters\n"
"  model.update(tree_unflatten(list(params.items())))\n"
"  return model(x)\n"
"\n"
"params = dict(tree_flatten(model.parameters()))\n"
"mx.export_function(\"model.mlxfn\", call, (mx.zeros(4),), params)"
msgstr ""

#: ../../../src/usage/export.rst:159
msgid "Shapeless Exports"
msgstr ""

#: ../../../src/usage/export.rst:161
msgid ""
"Just like :func:`compile`, functions can also be exported for dynamically "
"shaped inputs. Pass ``shapeless=True`` to :func:`export_function` or :func:"
"`exporter` to export a function which can be used for inputs with variable "
"shapes:"
msgstr ""

#: ../../../src/usage/export.rst:165
msgid ""
"mx.export_function(\"fun.mlxfn\", mx.abs, mx.array(0.0), shapeless=True)\n"
"imported_abs = mx.import_function(\"fun.mlxfn\")\n"
"\n"
"# Ok\n"
"out, = imported_abs(mx.array(-1.0))\n"
"\n"
"# Also ok\n"
"out, = imported_abs(mx.array([-1.0, -2.0]))"
msgstr ""

#: ../../../src/usage/export.rst:176
msgid ""
"With ``shapeless=False`` (which is the default), the second call to "
"``imported_abs`` would raise an exception with a shape mismatch."
msgstr ""

#: ../../../src/usage/export.rst:179
msgid ""
"Shapeless exporting works the same as shapeless compilation and should be "
"used carefully. See the :ref:`documentation on shapeless compilation "
"<shapeless_compile>` for more information."
msgstr ""

#: ../../../src/usage/export.rst:184
msgid "Exporting Multiple Traces"
msgstr ""

#: ../../../src/usage/export.rst:186
msgid ""
"In some cases, functions build different computation graphs for different "
"input arguments. A simple way to manage this is to export to a new file with "
"each set of inputs. This is a fine option in many cases. But it can be "
"suboptimal if the exported functions have a large amount of duplicate "
"constant data (for example the parameters of a :obj:`mlx.nn.Module`)."
msgstr ""

#: ../../../src/usage/export.rst:192
msgid ""
"The export API in MLX lets you export multiple traces of the same function "
"to a single file by creating an exporting context manager with :func:"
"`exporter`:"
msgstr ""

#: ../../../src/usage/export.rst:195
msgid ""
"def fun(x, y=None):\n"
"    constant = mx.array(3.0)\n"
"    if y is not None:\n"
"      x += y\n"
"    return x + constant\n"
"\n"
"with mx.exporter(\"fun.mlxfn\", fun) as exporter:\n"
"    exporter(mx.array(1.0))\n"
"    exporter(mx.array(1.0), y=mx.array(0.0))\n"
"\n"
"imported_function = mx.import_function(\"fun.mlxfn\")\n"
"\n"
"# Call the function with y=None\n"
"out, = imported_function(mx.array(1.0))\n"
"print(out)\n"
"\n"
"# Call the function with y specified\n"
"out, = imported_function(mx.array(1.0), y=mx.array(1.0))\n"
"print(out)"
msgstr ""

#: ../../../src/usage/export.rst:217
msgid ""
"In the above example the function constant data, (i.e. ``constant``), is "
"only saved once."
msgstr ""

#: ../../../src/usage/export.rst:221
msgid "Transformations with Imported Functions"
msgstr ""

#: ../../../src/usage/export.rst:223
msgid ""
"Function transformations like :func:`grad`, :func:`vmap`, and :func:"
"`compile` work on imported functions just like regular Python functions:"
msgstr ""

#: ../../../src/usage/export.rst:226
msgid ""
"def fun(x):\n"
"    return mx.sin(x)\n"
"\n"
"x = mx.array(0.0)\n"
"mx.export_function(\"sine.mlxfn\", fun, x)\n"
"\n"
"imported_fun = mx.import_function(\"sine.mlxfn\")\n"
"\n"
"# Take the derivative of the imported function\n"
"dfdx = mx.grad(lambda x: imported_fun(x)[0])\n"
"# Prints: array(1, dtype=float32)\n"
"print(dfdx(x))\n"
"\n"
"# Compile the imported function\n"
"mx.compile(imported_fun)\n"
"# Prints: array(0, dtype=float32)\n"
"print(compiled_fun(x)[0])"
msgstr ""

#: ../../../src/usage/export.rst:248
msgid "Importing Functions in C++"
msgstr ""

#: ../../../src/usage/export.rst:250
msgid ""
"Importing and running functions in C++ is basically the same as importing "
"and running them in Python. First, follow the :ref:`instructions "
"<mlx_in_cpp>` to setup a simple C++ project that uses MLX as a library."
msgstr ""

#: ../../../src/usage/export.rst:254
msgid "Next, export a simple function from Python:"
msgstr ""

#: ../../../src/usage/export.rst:256
msgid ""
"def fun(x, y):\n"
"    return mx.exp(x + y)\n"
"\n"
"x = mx.array(1.0)\n"
"y = mx.array(1.0)\n"
"mx.export_function(\"fun.mlxfn\", fun, x, y)"
msgstr ""

#: ../../../src/usage/export.rst:266
msgid "Import and run the function in C++ with only a few lines of code:"
msgstr ""

#: ../../../src/usage/export.rst:268
msgid ""
"auto fun = mx::import_function(\"fun.mlxfn\");\n"
"\n"
"auto inputs = {mx::array(1.0), mx::array(1.0)};\n"
"auto outputs = fun(inputs);\n"
"\n"
"// Prints: array(2, dtype=float32)\n"
"std::cout << outputs[0] << std::endl;"
msgstr ""

#: ../../../src/usage/export.rst:278
msgid ""
"Imported functions can be transformed in C++ just like in Python. Use ``std::"
"vector<mx::array>`` for positional arguments and ``std::map<std::string, mx::"
"array>`` for keyword arguments when calling imported functions in C++."
msgstr ""

#: ../../../src/usage/export.rst:283
msgid "More Examples"
msgstr ""

#: ../../../src/usage/export.rst:285
msgid ""
"Here are a few more complete examples exporting more complex functions from "
"Python and importing and running them in C++:"
msgstr ""

#: ../../../src/usage/export.rst:288
msgid ""
"`Inference and training a multi-layer perceptron <https://github.com/ml-"
"explore/mlx/tree/main/examples/export>`_"
msgstr ""
